%% load the file
fname = spm_select();
D = spm_eeg_load(fname);

%% creat bipolar montage
%Create bipolar for HFO and spike detection
% fprintf('%s\n','---- Creating bipolar montage ----')
Channel_labels_Raw = D.chanlabels;
% Find element which is not number in each label
Channel_labels_Init = cellfun(@(x) regexp(x,'[^0-9]','match'),Channel_labels_Raw);
Electrode_num = length(unique(Channel_labels_Init));
[Electrode_Name,a,b] = unique(Channel_labels_Init,'stable');
% Initialize the montage matrix
tra = zeros(length(D.chanlabels) - Electrode_num,length(D.chanlabels));
labelorg = Channel_labels_Raw;
% create montage matrix
Channel_ind_new = 1;
for i = 1:Electrode_num
    Electrode_Contacts = length(b(b == i));
    for j = 1:Electrode_Contacts-1
        name1 = strcat(Electrode_Name{i},num2str(j));
        name2 = strcat(Electrode_Name{i},num2str(j+1));
        labelnew{1,Channel_ind_new}=sprintf('%s-%s',name1,name2);
        % locate this two channels
        [~,Locb1] = ismember(name1,Channel_labels_Raw);
        [~,Locb2] = ismember(name2,Channel_labels_Raw);
        tra(Channel_ind_new,Locb1) = 1;
        tra(Channel_ind_new,Locb2) = -1;
        Channel_ind_new = Channel_ind_new + 1;
    end
end
montage.tra = tra;
montage.labelnew = labelnew;
montage.labelorg = labelorg;
spm_eeg_montage_ui(montage)
save('Bipolar_Montage_file','montage');

%  fields of S:
S.D = D;
S.montage  = montage;
S.updatehistory  = 1;
S.prefix         = 'BipM_';
D_M = spm_eeg_montage(S);

D_M = chantype(D_M,'all','EEG');
save(D_M)
% figure
% plot(D(21,1:10000,1)-D(24,1:10000,1))
% hold on
% plot(D_M(22,1:10000,1),'o')
%% line noise notch fileter of 50Hz
clear S
S.D  = D_M;

S.band  = 'stop';
S.freq  = [49.5 50.5];
%  Optional fields:
% S.type  =  'fir';
% S.order = 64;
S.prefix = '50Hz_Notch_';

D_M_notch = spm_eeg_filter(S); % D is filtered here
%% use spm to filter
% NOTE: set the eeg type before you filter
% set parameters
S.D  = D_M;

S.band  = 'bandpass';
S.freq  = [80 490];
%  Optional fields:
S.type  =  'fir';
S.order = 64;
S.prefix = 'fir64_80_490_';

D_Mf = spm_eeg_filter(S); % D is filtered here

% figure;
% plot(D(1,1:10000,1))
% hold on
% plot(D_f(1,1:10000,1))
% plot(input_filtered)

%% calculate the envelope of the signal using Hilbert transform
D_Mf = spm_eeg_load();
Envelope = envelope(D_Mf(4,1:1340000,1),10,'peak'); % the number in the middle 
% e.g. 10 in this case controls the smoothness of the envelope, 
% this can be arbitrary, so inspect the figure
% visualization for inspection of the envelope
signal_temp = D_Mf(4,1:1340000,1);
plotECG(D_Mf.time(1:1340000),[signal_temp' Envelope'])
evelope_mean = mean(Envelope);
evelope_std = std(Envelope);
threshold_5sd = evelope_std*5;
threshold_5sd_line = repmat(threshold_5sd,1340000,1);
threshold_mean_line = repmat(evelope_mean,1340000,1);
plotECG(D_Mf.time(1:1340000),[signal_temp' threshold_5sd_line Envelope' threshold_mean_line D_M(4,1:1340000,1)'])

% %plan B: use a std pool for each channel and extract the median std to
% avoid some noise or bias generated by the signal
% %% HFO detection using a sliding window
% % window length: 100ms
% SlidingWinDur = 0.1; % in s
% SlidingWin = SlidingWinDur*D_f.fsample;
% StepLength = 0.001; % in s
% DataLength = D_f.nsamples;
% StdPool = [];
% 
% %calculating the std pool for each channel
% for ChannelIdx = 1%D_f.nchannels
%     for i = 1:(StepLength * D_f.fsample):(DataLength - SlidingWinDur * D_f.fsample) % slide the window
%         DataInWindow = D_f(ChannelIdx,i:(SlidingWin+i-1),1); % extract time series data in one window
%         StdTemp = std(DataInWindow);
%         StdPool(ChannelIdx,i) = StdTemp;
%     end
% end
% 
% StdPool_Nonzero = [];
% Thresholds      = [];
% ThresholdLines  = [];
% nChannel = size(StdPool);
% nChannel = nChannel(1);
% for i = 1:nChannel
%     StdPoolTemp = StdPool(i,:);
%     StdPoolTemp = StdPoolTemp(StdPoolTemp ~= 0);
%     StdPool_Nonzero(i,:) = StdPoolTemp;
%     Thresholds(i,:) = median(StdPoolTemp) * 5;
%     ThresholdLines(i,:) = repelem(median(StdPoolTemp) * 5,D_f.nsamples)';
% end

%% plot traces demo
plotECG(D.time,squeeze(D(:,:,1)),'AutoStackSignals',D.chanlabels)
plotECG(D.time,squeeze(D(1,:,1)))

%% time frequency map using stft demo
Sig = squeeze(D(1,1:10000,1));
HanningWin = hann(64*D.fsample/1000);
Noverlap = length(HanningWin) - 1;
frequencies = 1:500;
fsample = D.fsample;
figure;
plot(Sig)
[s,w,t,ps] = spectrogram(Sig,HanningWin,Noverlap,frequencies,fsample,'yaxis');
figure
spectrogram(Sig,HanningWin,Noverlap,frequencies,fsample,'yaxis','MinThreshold',-20)
colormap('jet')

